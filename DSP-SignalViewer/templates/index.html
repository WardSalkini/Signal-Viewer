<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECG/EEG Signal Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script>
        function attachPan(chart) {
            const canvas = chart.canvas;
            let dragging = false, startX, startY, xMinAtStart, xMaxAtStart, yMinAtStart, yMaxAtStart;
            canvas.style.cursor = 'grab';
            canvas.addEventListener('mousedown', e => {
                if (e.button !== 0) return;
                dragging = true; startX = e.clientX; startY = e.clientY;
                xMinAtStart = chart.scales.x.min; xMaxAtStart = chart.scales.x.max;
                yMinAtStart = chart.scales.y.min; yMaxAtStart = chart.scales.y.max;
                canvas.style.cursor = 'grabbing'; e.preventDefault();
            });
            window.addEventListener('mousemove', e => {
                if (!dragging) return;
                const xs = chart.scales.x, ys = chart.scales.y;
                const xPixels = xs.right - xs.left || 1, yPixels = ys.bottom - ys.top || 1;
                const xRange = xMaxAtStart - xMinAtStart, yRange = yMaxAtStart - yMinAtStart;
                const dx = e.clientX - startX, dy = e.clientY - startY;
                chart.options.scales.x.min = xMinAtStart - (dx / xPixels) * xRange;
                chart.options.scales.x.max = xMaxAtStart - (dx / xPixels) * xRange;
                chart.options.scales.y.min = yMinAtStart + (dy / yPixels) * yRange;
                chart.options.scales.y.max = yMaxAtStart + (dy / yPixels) * yRange;
                chart.update('none');
            });
            window.addEventListener('mouseup', () => { if (dragging) { dragging = false; canvas.style.cursor = 'grab'; } });
            canvas.addEventListener('dblclick', () => {
                chart.options.scales.x.min = chart.options.scales.x.max =
                    chart.options.scales.y.min = chart.options.scales.y.max = undefined;
                chart.resetZoom();
            });
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .window {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: visible;
        }

        .window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .window-title {
            font-size: 1.2rem;
            color: #00d4ff;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: black;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.8rem;
            color: #aaa;
        }

        select,
        input[type="file"] {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.9rem;
        }

        select option {
            background: #1a1a2e;
        }

        .chart-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            height: 350px;
            position: relative;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 5px;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .zoom-btn:hover {
            background: #00d4ff;
        }

        .zoom-axis-btns {
            display: flex;
            gap: 3px;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid rgba(255, 255, 255, 0.3);
        }

        .axis-btn {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .axis-btn.active {
            background: #00d4ff;
            border-color: #00d4ff;
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .playback-controls button {
            font-size: 1.2rem;
            padding: 10px 20px;
        }

        .slider-container {
            flex: 1;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }

        .time-display {
            font-size: 1rem;
            color: #00d4ff;
            min-width: 120px;
            text-align: right;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .status.playing {
            background: #28a745;
        }

        .status.paused {
            background: #6c757d;
        }

        .channel-select {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .channel-btn {
            padding: 5px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .channel-btn.active {
            background: #00d4ff;
            border-color: #00d4ff;
        }

        .settings {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .settings input[type="range"] {
            width: 120px;
        }

        .add-window-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 10px;
        }

        /* XOR styles */
        .xor-legend {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.75rem;
            color: #ccc;
            margin-bottom: 8px;
            line-height: 1.6;
            display: none;
        }

        .xor-legend strong {
            color: #00d4ff;
        }

        .xor-chunk-info {
            background: rgba(0, 212, 255, 0.07);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 8px;
            padding: 7px 12px;
            font-size: 0.78rem;
            color: #bbb;
            margin-bottom: 8px;
            display: none;
        }

        .xor-chunk-info strong {
            color: #00d4ff;
        }

        /* Split view */
        .split-charts-container {
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .split-chart-row {
            height: 120px;
            position: relative;
        }

        .split-chart-row canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Channel popover */
        .ch-popover {
            position: absolute;
            background: #1e2a3a;
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 10px;
            padding: 12px;
            z-index: 1000;
            display: none;
            min-width: 180px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .ch-popover.open {
            display: block;
        }

        .ch-popover label {
            font-size: 0.75rem;
            color: #aaa;
            display: block;
            margin-bottom: 4px;
        }

        .ch-popover input[type="color"] {
            width: 100%;
            height: 28px;
            border: none;
            background: transparent;
            cursor: pointer;
            margin-bottom: 6px;
        }

        .ch-popover input[type="range"] {
            width: 100%;
        }

        /* View / polar mode buttons */
        .view-mode-btns,
        .polar-mode-btns {
            display: flex;
            gap: 4px;
        }

        .view-mode-btn,
        .polar-mode-btn {
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: transparent;
            color: #aaa;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }

        .view-mode-btn.active {
            background: #00d4ff;
            color: #000;
            border-color: #00d4ff;
        }

        .polar-mode-btn.active {
            background: #a55eea;
            color: #fff;
            border-color: #a55eea;
        }

        /* Classification */
        .classify-panel {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: none;
        }

        .classify-panel.visible {
            display: block;
        }

        .classify-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .classify-header h3 {
            font-size: 1rem;
            color: #00d4ff;
            margin: 0;
        }

        .classify-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .classify-card {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        .classify-card h4 {
            font-size: 0.85rem;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .badge {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 8px;
            font-weight: 600;
        }

        .badge-ai {
            background: #7b2cbf;
            color: white;
        }

        .badge-ml {
            background: #17a2b8;
            color: white;
        }

        .classify-result {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .classify-result.normal {
            color: #26de81;
        }

        .classify-result.abnormal {
            color: #ff6b6b;
        }

        .classify-conf {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 8px;
        }

        .prob-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
            font-size: 0.75rem;
        }

        .prob-label {
            width: 55px;
            text-align: right;
            color: #aaa;
            flex-shrink: 0;
        }

        .prob-bar-bg {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 3px;
            overflow: hidden;
        }

        .prob-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .prob-bar.high {
            background: #ff6b6b;
        }

        .prob-bar.medium {
            background: #ffc107;
        }

        .prob-bar.low {
            background: #26de81;
        }

        .prob-val {
            width: 38px;
            text-align: right;
            color: #ccc;
            flex-shrink: 0;
        }

        .classify-loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .classify-loading .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .ml-details {
            margin-top: 6px;
            font-size: 0.75rem;
            color: #aaa;
        }

        .ml-details li {
            margin-bottom: 2px;
            list-style: none;
            padding-left: 0;
        }

        .ml-details li::before {
            content: '‚Üí ';
            color: #00d4ff;
        }

        /* Cumulative polar info bar */
        .polar-accum-info {
            background: rgba(165, 94, 234, 0.08);
            border: 1px solid rgba(165, 94, 234, 0.3);
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 0.75rem;
            color: #bbb;
            margin-bottom: 8px;
            display: none;
        }

        .polar-accum-info strong {
            color: #a55eea;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üìä ECG/EEG Signal Viewer</h1>
        <p style="color:#888;margin-top:5px;">Scroll to zoom | Drag to pan | Double-click to reset</p>
    </div>
    <div class="container" id="windows-container"></div>
    <button class="btn btn-primary add-window-btn" onclick="addWindow()">+</button>

    <script>
        const COLORS = ['#00d4ff', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a55eea', '#ff9f43', '#26de81', '#fd79a8'];
        let windowCounter = 0, windows = {};

        class SignalWindow {
            constructor(id) {
                this.id = id;
                this.data = null; this.channels = []; this.selectedChannels = [];
                this.chart = null; this.isPlaying = false; this.position = 0;
                this.speed = 1; this.period = 1; this.windowSize = 2000;
                this.plotType = 'time'; this.animationId = null;
                this.viewMode = 'combined'; this.splitCharts = [];
                this.polarMode = 'latest'; this.polarAccum = {};
                // Track the last sample index that was committed to polarAccum
                // so we never double-count frames that revisit the same samples.
                this._polarAccumEnd = {};
                this.colormap = 'viridis'; this.channelProps = {};
                this.recurrencePoints = []; this.signalType = 'ecg';
                this.xorThreshold = 0.05;
                this.createElement();
            }

            createElement() {
                const html = `
            <div class="window" id="window-${this.id}">
                <div class="window-header">
                    <span class="window-title">üìä Window ${this.id}</span>
                    <button class="btn btn-danger" onclick="removeWindow(${this.id})">‚úï</button>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Data Source</label>
                        <input type="file" id="file-${this.id}" accept=".csv,.edf,.dat,.hea" multiple onchange="windows[${this.id}].loadFile(event)">
                    </div>
                    <div class="control-group">
                        <label>Signal Type</label>
                        <div style="display:flex;gap:10px;align-items:center;">
                            <label style="display:flex;align-items:center;gap:4px;cursor:pointer;color:#ff6b6b;">
                                <input type="radio" name="sigType-${this.id}" value="ecg" checked onchange="windows[${this.id}].setSignalType('ecg')"> ‚ù§Ô∏è ECG
                            </label>
                            <label style="display:flex;align-items:center;gap:4px;cursor:pointer;color:#00d4ff;">
                                <input type="radio" name="sigType-${this.id}" value="eeg" onchange="windows[${this.id}].setSignalType('eeg')"> üß† EEG
                            </label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Plot Type</label>
                        <select id="plotType-${this.id}" onchange="windows[${this.id}].setPlotType(this.value)">
                            <option value="time">Signal vs Time</option>
                            <option value="xor">XOR Graph</option>
                            <option value="chvsch">Channel vs Channel</option>
                            <option value="polar">Polar Plot</option>
                            <option value="polarRatio">Polar Ratio (|Ch1|/|Ch2|)</option>
                            <option value="recurrence">Recurrence Graph</option>
                        </select>
                    </div>
                </div>
                <div class="info" id="info-${this.id}">No data loaded</div>
                <div class="channel-select" id="channels-${this.id}"></div>
                <div class="channel-dropdowns" id="chDropdowns-${this.id}" style="display:none;margin-bottom:15px;">
                    <div style="display:flex;gap:15px;flex-wrap:wrap;">
                        <div class="control-group">
                            <label style="color:#00d4ff;">Channel 1 (X)</label>
                            <select id="ch1-${this.id}" onchange="windows[${this.id}].setCh1(this.value)" style="min-width:120px;"></select>
                        </div>
                        <div class="control-group">
                            <label style="color:#ff6b6b;">Channel 2 (Y)</label>
                            <select id="ch2-${this.id}" onchange="windows[${this.id}].setCh2(this.value)" style="min-width:120px;"></select>
                        </div>
                    </div>
                </div>
                <div class="settings">
                    <div class="control-group">
                        <label>Speed: <span id="speedVal-${this.id}">1.0</span>x</label>
                        <input type="range" min="0.1" max="5" step="0.1" value="1" onchange="windows[${this.id}].setSpeed(this.value)">
                    </div>
                    <div class="control-group" id="periodGroup-${this.id}" style="display:none;">
                        <label>Period: <span id="periodVal-${this.id}">1.0</span>s</label>
                        <input type="range" min="0.2" max="5" step="0.1" value="1" onchange="windows[${this.id}].setPeriod(this.value)">
                    </div>
                    <div class="control-group" id="windowGroup-${this.id}">
                        <label>Window: <span id="windowVal-${this.id}">4.0</span>s</label>
                        <input type="range" id="windowSlider-${this.id}" min="0.5" max="20" step="0.5" value="4" onchange="windows[${this.id}].setWindowSize(this.value)">
                    </div>
                    <div class="control-group" id="viewModeGroup-${this.id}">
                        <label>View Mode</label>
                        <div class="view-mode-btns">
                            <button class="view-mode-btn active" onclick="windows[${this.id}].setViewMode('combined',this)">Combined</button>
                            <button class="view-mode-btn" onclick="windows[${this.id}].setViewMode('split',this)">Split</button>
                        </div>
                    </div>
                    <div class="control-group" id="polarModeGroup-${this.id}" style="display:none;">
                        <label>Polar Mode</label>
                        <div class="polar-mode-btns">
                            <button class="polar-mode-btn active" onclick="windows[${this.id}].setPolarMode('latest',this)">Latest</button>
                            <button class="polar-mode-btn" onclick="windows[${this.id}].setPolarMode('cumulative',this)">Cumulative</button>
                        </div>
                    </div>
                    <div class="control-group" id="colormapGroup-${this.id}" style="display:none;">
                        <label>Colormap</label>
                        <select id="colormapSelect-${this.id}" onchange="windows[${this.id}].setColormap(this.value)">
                            <option value="viridis">Viridis</option>
                            <option value="plasma">Plasma</option>
                            <option value="cool">Cool</option>
                            <option value="warm">Warm</option>
                            <option value="grayscale">Grayscale</option>
                        </select>
                    </div>
                    <div class="control-group" id="xorThreshGroup-${this.id}" style="display:none;">
                        <label>Same-value Œµ: <span id="xorThreshVal-${this.id}">0.050</span></label>
                        <input type="range" min="0.001" max="0.5" step="0.001" value="0.05"
                            oninput="windows[${this.id}].setXorThreshold(this.value)">
                    </div>
                </div>

                <div class="xor-legend" id="xorLegend-${this.id}">
                    <strong>‚äï XOR Operation (normalised signal-domain):</strong><br>
                    <span style="color:#26de81;">‚ñ† Green dashed</span> ‚Äî both chunks equal within Œµ ‚Üí result = 0 (identical)<br>
                    <span style="color:#ff6b6b;">‚ñ† Red dashed</span> ‚Äî chunks differ ‚Üí result = (cur + prev) / 2<br>
                    <span style="color:#ffe66d;">‚ñ† Yellow</span> = previous chunk &nbsp;|&nbsp; <strong style="color:#00d4ff;">Cyan</strong> = current chunk
                </div>
                <div class="xor-chunk-info" id="xorChunkInfo-${this.id}"></div>

                <div class="polar-accum-info" id="polarAccumInfo-${this.id}"></div>

                <div id="chPopover-${this.id}" class="ch-popover"></div>

                <div class="chart-container" id="chartContainer-${this.id}">
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="windows[${this.id}].zoomIn()">+</button>
                        <button class="zoom-btn" onclick="windows[${this.id}].zoomOut()">‚àí</button>
                        <button class="zoom-btn" onclick="windows[${this.id}].resetZoom()">‚Ü∫</button>
                        <div class="zoom-axis-btns">
                            <button class="axis-btn active" onclick="windows[${this.id}].setZoomMode('xy',this)">XY</button>
                            <button class="axis-btn" onclick="windows[${this.id}].setZoomMode('x',this)">X</button>
                            <button class="axis-btn" onclick="windows[${this.id}].setZoomMode('y',this)">Y</button>
                        </div>
                    </div>
                    <canvas id="chart-${this.id}"></canvas>
                </div>

                <div class="playback-controls">
                    <button class="btn btn-success" onclick="windows[${this.id}].play()">‚ñ∂</button>
                    <button class="btn btn-warning" onclick="windows[${this.id}].pause()">‚è∏</button>
                    <button class="btn btn-primary" onclick="windows[${this.id}].reset()">‚Ü∫</button>
                    <div class="slider-container">
                        <input type="range" id="position-${this.id}" min="0" max="100" value="0"
                            oninput="windows[${this.id}].setPosition(this.value)">
                    </div>
                    <div class="time-display">
                        <span class="status paused" id="status-${this.id}">‚èπ Paused</span>
                        <div id="time-${this.id}">0.00s / 0.00s</div>
                    </div>
                </div>

                <div class="classify-panel" id="classify-${this.id}">
                    <div class="classify-header">
                        <h3>üî¨ Classification Results</h3>
                        <button class="btn btn-info" style="padding:4px 10px;font-size:0.75rem;" onclick="windows[${this.id}].runClassification()">Re-run</button>
                    </div>
                    <div id="classify-content-${this.id}">
                        <div class="classify-loading"><span class="spinner"></span> Analyzing signal...</div>
                    </div>
                </div>
            </div>`;
                document.getElementById('windows-container').insertAdjacentHTML('beforeend', html);
                this.initChart();
            }

            // ‚îÄ‚îÄ Canvas / chart init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            _freshCanvas() {
                const old = document.getElementById(`chart-${this.id}`);
                const c = document.createElement('canvas');
                c.id = `chart-${this.id}`;
                old.parentNode.replaceChild(c, old);
                return c.getContext('2d');
            }

            _destroyChart() {
                if (this.chart) { try { this.chart.destroy(); } catch (e) { } this.chart = null; }
            }

            initChart() {
                this._destroyChart();
                const ctx = this._freshCanvas();
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        interaction: { mode: 'nearest', intersect: false },
                        plugins: {
                            legend: { labels: { color: '#fff' } },
                            zoom: { zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy', drag: { enabled: false } }, pan: { enabled: false } }
                        },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa' }, title: { display: true, text: 'Time (s)', color: '#aaa' } },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa' }, title: { display: true, text: 'Amplitude', color: '#aaa' } }
                        }
                    }
                });
                attachPan(this.chart);
            }

            initScatterChart() {
                this._destroyChart();
                const ctx = this._freshCanvas();
                this.chart = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        plugins: { legend: { labels: { color: '#fff' } }, zoom: { zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' }, pan: { enabled: false } } },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa' }, title: { display: true, text: '', color: '#00d4ff' } },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa' }, title: { display: true, text: '', color: '#ff6b6b' } }
                        }
                    }
                });
                attachPan(this.chart);
            }

            initPolarChart() {
                this._destroyChart();
                const ctx = this._freshCanvas();
                this.chart = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true, maintainAspectRatio: false, animation: false,
                        plugins: { legend: { labels: { color: '#fff' } }, zoom: { zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' }, pan: { enabled: false } } },
                        scales: {
                            x: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa' }, title: { display: true, text: 'X (r¬∑cos Œ∏)', color: '#aaa' } },
                            y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa' }, title: { display: true, text: 'Y (r¬∑sin Œ∏)', color: '#aaa' } }
                        }
                    }
                });
                attachPan(this.chart);
            }

            // ‚îÄ‚îÄ Zoom ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            _chartTargets() { return this.viewMode === 'split' && this.splitCharts.length ? this.splitCharts : [this.chart]; }
            zoomIn() { this._chartTargets().forEach(c => c.zoom(1.2)); }
            zoomOut() { this._chartTargets().forEach(c => c.zoom(0.8)); }
            resetZoom() { this._chartTargets().forEach(c => c.resetZoom()); }
            setZoomMode(mode, btn) {
                document.querySelectorAll(`#window-${this.id} .axis-btn`).forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this._chartTargets().forEach(c => { c.options.plugins.zoom.zoom.mode = mode; c.update('none'); });
            }

            // ‚îÄ‚îÄ File loading ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            async loadFile(event) {
                const files = event.target.files;
                if (!files || !files.length) return;
                document.getElementById(`info-${this.id}`).textContent = 'Loading file...';
                const formData = new FormData();
                formData.append('window_id', String(this.id));
                for (let i = 0; i < files.length; i++) formData.append('file', files[i]);
                try {
                    const res = await fetch('/api/upload', { method: 'POST', body: formData });
                    const info = await res.json();
                    if (info.success) await this.loadData(info);
                    else { document.getElementById(`info-${this.id}`).textContent = 'Error loading file'; alert('Error: ' + info.error); }
                } catch (e) { document.getElementById(`info-${this.id}`).textContent = 'Upload failed'; alert('Upload failed: ' + e.message); }
            }

            async loadData(info) {
                this.channels = info.channels; this.sr = info.sr;
                this.duration = info.duration; this.nSamples = info.n_samples;
                if (info.signal_type) {
                    this.signalType = info.signal_type;
                    const r = document.querySelector(`input[name="sigType-${this.id}"][value="${info.signal_type}"]`);
                    if (r) r.checked = true;
                }
                const res = await fetch(`/api/all_data?window_id=${this.id}`);
                this.data = await res.json();

                // Pre-compute global min/max for each channel so r is consistent
                // across all windows and frames (not re-scaled per slice).
                this.globalMin = {}; this.globalMax = {};
                for (const ch of this.channels) {
                    const sig = this.data.signals[ch];
                    this.globalMin[ch] = Math.min(...sig);
                    this.globalMax[ch] = Math.max(...sig);
                }
                document.getElementById(`info-${this.id}`).textContent =
                    `${this.channels.length} channels | ${this.sr.toFixed(0)} Hz | ${this.duration.toFixed(1)}s`;

                const container = document.getElementById(`channels-${this.id}`);
                container.innerHTML = this.channels.map((ch, i) =>
                    `<button class="channel-btn ${i < 2 ? 'active' : ''}"
                    onclick="windows[${this.id}].toggleChannel('${ch}',this)"
                    oncontextmenu="event.preventDefault();windows[${this.id}].toggleChProps('${ch}',this)">${ch}</button>`
                ).join('');
                this.selectedChannels = this.channels.slice(0, Math.min(2, this.channels.length));

                const opts = this.channels.map(ch => `<option value="${ch}">${ch}</option>`).join('');
                document.getElementById(`ch1-${this.id}`).innerHTML = opts;
                document.getElementById(`ch2-${this.id}`).innerHTML = opts;
                if (this.channels.length > 1) document.getElementById(`ch2-${this.id}`).selectedIndex = 1;
                this.ch1 = this.channels[0];
                this.ch2 = this.channels.length > 1 ? this.channels[1] : this.channels[0];

                const ws = document.getElementById(`windowSlider-${this.id}`);
                ws.max = this.duration.toFixed(1);
                const iw = Math.min(4, this.duration);
                ws.value = iw;
                document.getElementById(`windowVal-${this.id}`).textContent = iw.toFixed(1);
                this.windowSize = Math.floor(this.sr * iw);
                document.getElementById(`position-${this.id}`).max = Math.max(0, this.nSamples - this.windowSize);

                this.updateChart();
                this.runClassification();
            }

            // ‚îÄ‚îÄ Classification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            async runClassification() {
                const panel = document.getElementById(`classify-${this.id}`);
                const content = document.getElementById(`classify-content-${this.id}`);
                panel.classList.add('visible');
                content.innerHTML = '<div class="classify-loading"><span class="spinner"></span> Analyzing signal...</div>';
                try {
                    const res = await fetch(`/api/classify?window_id=${this.id}`);
                    const data = await res.json();
                    content.innerHTML = data.success ? this.buildClassifyHTML(data) : `<div style="color:#ff6b6b;">Error: ${data.error}</div>`;
                } catch (e) { content.innerHTML = `<div style="color:#ff6b6b;">Classification failed: ${e.message}</div>`; }
            }

            buildClassifyHTML(data) {
                const ai = data.ai, ml = data.ml;
                const sigType = data.signal_type === 'ecg' ? '‚ù§Ô∏è ECG' : 'üß† EEG';
                const makeBars = p => p ? Object.entries(p).sort((a, b) => b[1] - a[1]).map(([k, v]) => {
                    const cls = v > 50 ? 'high' : v > 25 ? 'medium' : 'low';
                    return `<div class="prob-row"><span class="prob-label">${k}</span>
                    <div class="prob-bar-bg"><div class="prob-bar ${cls}" style="width:${Math.min(v, 100)}%"></div></div>
                    <span class="prob-val">${v.toFixed(1)}%</span></div>`;
                }).join('') : '';
                const isAiN = ai.prediction === 'NORMAL' || ai.prediction === 'NORM';
                const isMlN = ml.prediction === 'NORMAL' || ml.prediction === 'NORM';
                let mlDet = '', aiDet = '';
                if (ml.details) {
                    const r = ml.details.reasons || [];
                    if (r.length) mlDet = `<ul class="ml-details">${r.map(x => `<li>${x}</li>`).join('')}</ul>`;
                    if (ml.details.heart_rate !== undefined) mlDet += `<div style="font-size:0.7rem;color:#666;margin-top:4px;">HR: ${ml.details.heart_rate.toFixed(0)} bpm | Peaks: ${ml.details.n_peaks}</div>`;
                }
                if (ai.details && ai.details.detected_pathologies && ai.details.detected_pathologies.length)
                    aiDet = `<div style="margin-top:6px;font-size:0.75rem;"><strong style="color:#ff6b6b;">Detected:</strong>
                    <ul class="ml-details" style="margin-top:2px;">${ai.details.detected_pathologies.map(d => `<li>${d.name} (${d.confidence.toFixed(1)}%)</li>`).join('')}</ul></div>`;
                return `<div style="font-size:0.8rem;color:#888;margin-bottom:10px;">Signal: ${sigType} | ${data.signal_type.toUpperCase()}</div>
                <div class="classify-grid">
                    <div class="classify-card">
                        <h4>ü§ñ AI Model <span class="badge badge-ai">${ai.model || 'DenseNet1D'}</span></h4>
                        <div class="classify-result ${isAiN ? 'normal' : 'abnormal'}">${isAiN ? '‚úÖ' : '‚ö†Ô∏è'} ${ai.class_name || ai.prediction}</div>
                        <div class="classify-conf">Confidence: ${ai.confidence.toFixed(1)}%</div>
                        ${makeBars(ai.probabilities)}${aiDet}
                    </div>
                    <div class="classify-card">
                        <h4>üìä Classic ML <span class="badge badge-ml">${ml.model || 'Statistics'}</span></h4>
                        <div class="classify-result ${isMlN ? 'normal' : 'abnormal'}">${isMlN ? '‚úÖ' : '‚ö†Ô∏è'} ${ml.class_name || ml.prediction}</div>
                        <div class="classify-conf">Confidence: ${ml.confidence.toFixed(1)}%</div>
                        ${makeBars(ml.probabilities)}${mlDet}
                    </div>
                </div>`;
            }

            // ‚îÄ‚îÄ Controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            toggleChannel(ch, btn) {
                if (this.selectedChannels.includes(ch)) { this.selectedChannels = this.selectedChannels.filter(c => c !== ch); btn.classList.remove('active'); }
                else { this.selectedChannels.push(ch); btn.classList.add('active'); }
                this.updateChart();
            }
            setCh1(val) { this.ch1 = val; this.updateChart(); }
            setCh2(val) { this.ch2 = val; this.updateChart(); }

            setPlotType(type) {
                this.plotType = type;
                this.recurrencePoints = [];
                this._resetPolarAccum();
                const isXor = type === 'xor';

                // Toggle UI sections
                document.getElementById(`periodGroup-${this.id}`).style.display = type.includes('polar') ? 'block' : 'none';
                document.getElementById(`viewModeGroup-${this.id}`).style.display = type === 'time' ? 'block' : 'none';
                document.getElementById(`polarModeGroup-${this.id}`).style.display = type === 'polar' ? 'block' : 'none';
                document.getElementById(`colormapGroup-${this.id}`).style.display = (isXor || type === 'recurrence') ? 'block' : 'none';
                document.getElementById(`xorThreshGroup-${this.id}`).style.display = isXor ? 'block' : 'none';
                document.getElementById(`xorLegend-${this.id}`).style.display = isXor ? 'block' : 'none';
                document.getElementById(`xorChunkInfo-${this.id}`).style.display = isXor ? 'block' : 'none';
                document.getElementById(`polarAccumInfo-${this.id}`).style.display =
                    (type === 'polar' || type === 'polarRatio') ? 'block' : 'none';

                const needDropdowns = type === 'chvsch' || type === 'polarRatio' || type === 'recurrence';
                document.getElementById(`channels-${this.id}`).style.display = needDropdowns ? 'none' : 'flex';
                document.getElementById(`chDropdowns-${this.id}`).style.display = needDropdowns ? 'block' : 'none';

                this.destroySplitCharts();
                document.getElementById(`chartContainer-${this.id}`).style.display = 'block';

                if (type === 'chvsch' || type === 'recurrence') this.initScatterChart();
                else if (type.includes('polar')) this.initPolarChart();
                else this.initChart();

                this.updateChart();
            }

            setSpeed(val) { this.speed = parseFloat(val); document.getElementById(`speedVal-${this.id}`).textContent = val; }
            setPeriod(val) {
                this.period = parseFloat(val);
                document.getElementById(`periodVal-${this.id}`).textContent = val;
                // Changing period changes the angular mapping ‚Üí reset accumulation
                this._resetPolarAccum();
                this.updateChart();
            }
            setXorThreshold(val) {
                this.xorThreshold = parseFloat(val);
                document.getElementById(`xorThreshVal-${this.id}`).textContent = parseFloat(val).toFixed(3);
                this.updateChart();
            }
            setViewMode(mode, btn) {
                this.viewMode = mode;
                document.querySelectorAll(`#window-${this.id} .view-mode-btn`).forEach(b => b.classList.remove('active')); btn.classList.add('active');
                this.destroySplitCharts();
                if (mode === 'combined') document.getElementById(`chartContainer-${this.id}`).style.display = 'block';
                this.updateChart();
            }
            setSignalType(type) { this.signalType = type; if (this.data) { fetch(`/api/set_signal_type?window_id=${this.id}&signal_type=${type}`); this.runClassification(); } }
            setPolarMode(mode, btn) {
                this.polarMode = mode;
                this._resetPolarAccum();
                document.querySelectorAll(`#window-${this.id} .polar-mode-btn`).forEach(b => b.classList.remove('active')); btn.classList.add('active');
                this.updateChart();
            }
            setColormap(val) { this.colormap = val; this.updateChart(); }

            // ‚îÄ‚îÄ Polar accumulation helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            _resetPolarAccum() {
                this.polarAccum = {};
                this._polarAccumEnd = {};
            }

            /**
             * Compute polar (x,y) points for a channel slice [start, end).
             * Uses the ABSOLUTE sample index so Œ∏ is continuous during playback.
             */
            _computePolarPoints(ch, start, end) {
                const sig = this.data.signals[ch].slice(start, end);
                // Use global min/max so r is consistent across all windows
                const mn = this.globalMin[ch] ?? Math.min(...sig);
                const mx = this.globalMax[ch] ?? Math.max(...sig);
                const rng = mx - mn || 1;
                const pts = [];
                for (let i = 0; i < sig.length; i += 2) {
                    const absIdx = start + i;
                    const theta = ((absIdx / this.sr) / this.period) * 2 * Math.PI;
                    const r = (sig[i] - mn) / rng + 0.5;
                    pts.push({ x: r * Math.cos(theta), y: r * Math.sin(theta) });
                }
                return pts;
            }

            /**
             * Append only the NEW portion of the signal to polarAccum[ch].
             *
             * The key insight: in cumulative mode we want to keep every sample that
             * has scrolled past, but we must NOT re-add samples that were already
             * committed in a previous frame.
             *
             * Strategy:
             *   - _polarAccumEnd[ch] tracks the sample index up to which we have
             *     already committed points.
             *   - Each call appends [max(start, _polarAccumEnd[ch]), end).
             *   - If the playback wraps around (position resets to 0 or the user
             *     drags the slider backwards) we detect the regression and wipe the
             *     accumulator so the trace restarts cleanly.
             */
            _appendPolarAccum(ch, start, end) {
                if (!this.polarAccum[ch]) {
                    this.polarAccum[ch] = [];
                    this._polarAccumEnd[ch] = 0;
                }

                const prevEnd = this._polarAccumEnd[ch];

                // Detect backward scrub / wrap-around ‚Üí reset for this channel
                if (start < prevEnd - this.windowSize) {
                    this.polarAccum[ch] = [];
                    this._polarAccumEnd[ch] = 0;
                }

                // Only compute points for the truly new samples
                const newStart = Math.max(start, this._polarAccumEnd[ch]);
                if (newStart >= end) return; // nothing new to add

                const sig = this.data.signals[ch];
                const mn = this.globalMin[ch] ?? Math.min(...sig);
                const mx = this.globalMax[ch] ?? Math.max(...sig);
                const rng = mx - mn || 1;

                for (let i = newStart; i < end; i += 2) {
                    const theta = ((i / this.sr) / this.period) * 2 * Math.PI;
                    const r = (sig[i] - mn) / rng + 0.5;
                    this.polarAccum[ch].push({ x: r * Math.cos(theta), y: r * Math.sin(theta) });
                }

                this._polarAccumEnd[ch] = end;

                // Cap to avoid unbounded memory growth (~25 k pts ‚âà a few minutes at 500 Hz)
                const MAX_PTS = 25000;
                if (this.polarAccum[ch].length > MAX_PTS) {
                    this.polarAccum[ch] = this.polarAccum[ch].slice(-MAX_PTS);
                }
            }

            destroySplitCharts() {
                this.splitCharts.forEach(c => c.destroy()); this.splitCharts = [];
                const el = document.getElementById(`splitContainer-${this.id}`); if (el) el.remove();
            }

            getColormapColor(t) {
                t = Math.max(0, Math.min(1, t));
                const maps = { viridis: [[68, 1, 84], [59, 82, 139], [33, 145, 140], [94, 201, 98], [253, 231, 37]], plasma: [[13, 8, 135], [126, 3, 168], [204, 71, 120], [248, 149, 64], [240, 249, 33]], cool: [[0, 255, 255], [0, 128, 255], [0, 0, 255], [128, 0, 255], [255, 0, 255]], warm: [[255, 255, 0], [255, 192, 0], [255, 128, 0], [255, 64, 0], [255, 0, 0]], grayscale: [[0, 0, 0], [64, 64, 64], [128, 128, 128], [192, 192, 192], [255, 255, 255]] };
                const pts = maps[this.colormap] || maps.viridis, idx = t * (pts.length - 1), lo = Math.floor(idx), hi = Math.min(lo + 1, pts.length - 1), f = idx - lo;
                const r = Math.round(pts[lo][0] * (1 - f) + pts[hi][0] * f);
                const g = Math.round(pts[lo][1] * (1 - f) + pts[hi][1] * f);
                const b = Math.round(pts[lo][2] * (1 - f) + pts[hi][2] * f);
                return '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
            }
            getChannelColor(ch, idx) { return (this.channelProps[ch] && this.channelProps[ch].color) || COLORS[idx % COLORS.length]; }
            getChannelThickness(ch) { return (this.channelProps[ch] && this.channelProps[ch].thickness) || 1.5; }

            toggleChProps(ch, btnEl) {
                const pop = document.getElementById(`chPopover-${this.id}`);
                if (pop.classList.contains('open') && pop.dataset.ch === ch) { pop.classList.remove('open'); return; }
                if (!this.channelProps[ch]) { const idx = this.channels.indexOf(ch); this.channelProps[ch] = { color: COLORS[idx % COLORS.length], thickness: 1.5 }; }
                let hx = this.channelProps[ch].color;
                if (hx.length === 4) hx = '#' + hx[1] + hx[1] + hx[2] + hx[2] + hx[3] + hx[3];
                pop.dataset.ch = ch;
                pop.innerHTML = `<label style="color:#ddd;font-size:0.8rem;margin-bottom:6px;display:block;">üé® ${ch}</label>
                <label>Color</label><input type="color" value="${hx}" onchange="windows[${this.id}].channelProps['${ch}'].color=this.value;windows[${this.id}].updateChart()">
                <label>Thickness: <span id="thickVal-${this.id}-${ch}">${this.channelProps[ch].thickness}</span>px</label>
                <input type="range" min="0.5" max="5" step="0.5" value="${this.channelProps[ch].thickness}"
                    oninput="windows[${this.id}].channelProps['${ch}'].thickness=parseFloat(this.value);document.getElementById('thickVal-${this.id}-${ch}').textContent=this.value;windows[${this.id}].updateChart()">`;
                const r = btnEl.getBoundingClientRect(), wr = document.getElementById(`window-${this.id}`).getBoundingClientRect();
                pop.style.top = (r.bottom - wr.top + 5) + 'px'; pop.style.left = (r.left - wr.left) + 'px';
                pop.classList.add('open');
            }

            // ‚îÄ‚îÄ Split view ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            _syncSplitZoom(src) {
                this.splitCharts.forEach(c => {
                    if (c === src) return;
                    c.options.scales.x.min = src.scales.x.min; c.options.scales.x.max = src.scales.x.max;
                    c.options.scales.y.min = src.scales.y.min; c.options.scales.y.max = src.scales.y.max;
                    c.update('none');
                });
            }

            createSplitView(start, end) {
                if (this.splitCharts.length === this.selectedChannels.length && this.splitCharts.length > 0) { this.updateSplitView(start, end); return; }
                this.destroySplitCharts();
                document.getElementById(`chartContainer-${this.id}`).style.display = 'none';
                const parent = document.getElementById(`chartContainer-${this.id}`).parentElement;
                const container = document.createElement('div');
                container.id = `splitContainer-${this.id}`; container.className = 'split-charts-container';
                parent.insertBefore(container, document.getElementById(`chartContainer-${this.id}`));
                const labels = this.data.time.slice(start, end).map(t => t.toFixed(3)), winRef = this;
                this.selectedChannels.forEach((ch, idx) => {
                    const row = document.createElement('div'); row.className = 'split-chart-row';
                    const canvas = document.createElement('canvas'); row.appendChild(canvas); container.appendChild(row);
                    const chart = new Chart(canvas.getContext('2d'), {
                        type: 'line',
                        data: { labels, datasets: [{ label: ch, data: this.data.signals[ch].slice(start, end), borderColor: this.getChannelColor(ch, idx), borderWidth: this.getChannelThickness(ch), pointRadius: 0, fill: false, tension: 0.1 }] },
                        options: {
                            responsive: true, maintainAspectRatio: false, animation: false,
                            plugins: { legend: { labels: { color: '#fff', font: { size: 10 } } }, zoom: { zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy', onZoomComplete: ({ chart }) => winRef._syncSplitZoom(chart) }, pan: { enabled: false } } },
                            scales: { x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#888', maxTicksLimit: 6 } }, y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#888' } } }
                        }
                    });
                    this.splitCharts.push(chart); attachPan(chart);
                    chart.canvas.addEventListener('mousemove', () => requestAnimationFrame(() => winRef._syncSplitZoom(chart)));
                });
            }

            updateSplitView(start, end) {
                const labels = this.data.time.slice(start, end).map(t => t.toFixed(3));
                this.splitCharts.forEach((chart, idx) => {
                    const ch = this.selectedChannels[idx]; if (!ch) return;
                    chart.data.labels = labels;
                    chart.data.datasets[0].data = this.data.signals[ch].slice(start, end);
                    chart.data.datasets[0].borderColor = this.getChannelColor(ch, idx);
                    chart.data.datasets[0].borderWidth = this.getChannelThickness(ch);
                    chart.update('none');
                });
            }

            // ‚îÄ‚îÄ XOR GRAPH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            updateXorChart(start, end) {
                if (!this.selectedChannels.length) return;

                const ch = this.selectedChannels[0];
                const fullSignal = this.data.signals[ch];
                const chunkLen = this.windowSize;
                const totalChunks = Math.floor(fullSignal.length / chunkLen);
                const Œµ = this.xorThreshold;

                if (totalChunks < 1) {
                    this.chart.data.labels = []; this.chart.data.datasets = [];
                    this.chart.update('none'); return;
                }

                const currentIdx = Math.min(Math.floor(start / chunkLen), totalChunks - 1);
                const prevIdx = currentIdx === 0 ? totalChunks - 1 : currentIdx - 1;

                const half = 5;
                const cStart = Math.max(0, currentIdx - half);
                const cEnd = Math.min(totalChunks, currentIdx + half + 1);
                const visible = cEnd - cStart;

                const step = Math.max(1, Math.floor(chunkLen / 2000));

                const labels = [];
                for (let i = 0; i < chunkLen; i += step) labels.push((i / this.sr).toFixed(3));

                const normalise = arr => {
                    const mn = Math.min(...arr), mx = Math.max(...arr), rng = (mx - mn) || 1;
                    return arr.map(v => (v - mn) / rng * 2 - 1);
                };

                const curRaw = Array.from(fullSignal.slice(currentIdx * chunkLen, (currentIdx + 1) * chunkLen));
                const prevRaw = Array.from(fullSignal.slice(prevIdx * chunkLen, (prevIdx + 1) * chunkLen));
                const curNorm = normalise(curRaw);
                const prevNorm = normalise(prevRaw);

                const datasets = [];

                for (let c = cStart; c < cEnd; c++) {
                    const isCur = c === currentIdx;
                    const isPrev = c === prevIdx;
                    const chunk = Array.from(fullSignal.slice(c * chunkLen, (c + 1) * chunkLen));
                    const normC = normalise(chunk);

                    const t = visible > 1 ? (c - cStart) / (visible - 1) : 0.5;

                    let borderColor, width, order;
                    if (isCur) {
                        borderColor = '#00d4ff'; width = 2.5; order = 1;
                    } else if (isPrev) {
                        borderColor = '#ffe66d'; width = 2; order = 2;
                    } else {
                        borderColor = this.getColormapColor(t) + 'aa'; width = 0.9; order = 3;
                    }

                    const data = [];
                    for (let i = 0; i < normC.length; i += step) data.push(normC[i] ?? 0);

                    datasets.push({
                        label: `Chunk ${c + 1}${isCur ? ' ‚óÄ NOW' : isPrev ? ' ‚óÄ PREV' : ''}`,
                        data, borderColor, borderWidth: width,
                        pointRadius: 0, fill: false, tension: 0, order,
                        type: 'line'
                    });
                }

                const xorPoints = [], xorColors = [], zeroData = [];
                let nSame = 0, nDiff = 0;
                const len = Math.min(curNorm.length, prevNorm.length);

                for (let i = 0; i < len; i += step) {
                    const a = curNorm[i] ?? 0;
                    const b = prevNorm[i] ?? 0;
                    const diff = Math.abs(a - b);
                    const same = diff <= Œµ;

                    const yVal = same ? 0 : (a + b) / 2;
                    const t = Math.min(diff / 2, 1);
                    xorPoints.push({ x: labels[xorPoints.length] ?? i, y: yVal });
                    xorColors.push(this.getColormapColor(t));
                    zeroData.push(0);
                    same ? nSame++ : nDiff++;
                }

                datasets.push({
                    label: '‚îÄ‚îÄ Zero (same-value baseline)',
                    data: zeroData,
                    borderColor: 'rgba(38,222,129,0.6)',
                    borderWidth: 1.5, borderDash: [4, 4],
                    pointRadius: 0, fill: false, tension: 0,
                    order: 0, type: 'line'
                });

                datasets.push({
                    label: '‚äï XOR result (colormap = deviation)',
                    data: xorPoints,
                    backgroundColor: xorColors,
                    borderColor: xorColors,
                    pointRadius: 2.5,
                    pointHoverRadius: 4,
                    showLine: true,
                    borderWidth: 1.5,
                    fill: false,
                    tension: 0.1,
                    order: -1,
                    type: 'scatter'
                });

                const total = nSame + nDiff;
                const pSame = total ? (nSame / total * 100).toFixed(1) : '‚Äî';
                const pDiff = total ? (nDiff / total * 100).toFixed(1) : '‚Äî';
                const wrapNote = currentIdx === 0 ? ' <em>(wrap: compared with last chunk)</em>' : '';
                document.getElementById(`xorChunkInfo-${this.id}`).innerHTML =
                    `<strong>Chunk ${currentIdx + 1}</strong> ‚äï <strong>Chunk ${prevIdx + 1}</strong>${wrapNote} &nbsp;|&nbsp;
                Œµ=${Œµ.toFixed(3)} &nbsp;|&nbsp;
                <span style="color:#26de81;">Same: ${pSame}%</span> &nbsp;
                <span style="color:#ff6b6b;">Differ: ${pDiff}%</span> &nbsp;|&nbsp;
                Total chunks: ${totalChunks} &nbsp;|&nbsp;
                Colormap: <strong style="color:#00d4ff;">${this.colormap}</strong>
                <span style="color:#888;font-size:0.72rem;">(low end=same ¬∑ high end=diff)</span>`;

                this.chart.data.labels = labels;
                this.chart.data.datasets = datasets;
                this.chart.options.scales.x.title.text =
                    `Time within chunk (s) ‚Äî Chunk ${currentIdx + 1}/${totalChunks}  |  Œµ=${Œµ.toFixed(3)} (normalised)`;
                this.chart.options.scales.y.title.text = 'Amplitude (normalised to [-1, +1])';
                this.chart.update('none');
            }

            // ‚îÄ‚îÄ Recurrence ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            updateRecurrenceChart(start, end) {
                if (!this.ch1 || !this.ch2) return;
                const d1 = this.data.signals[this.ch1].slice(start, end), d2 = this.data.signals[this.ch2].slice(start, end);
                const step = Math.max(1, Math.floor(d1.length / 500));
                for (let i = 0; i < d1.length; i += step) this.recurrencePoints.push({ x: d1[i], y: d2[i] });
                if (this.recurrencePoints.length > 10000) this.recurrencePoints = this.recurrencePoints.slice(-10000);
                const colors = this.recurrencePoints.map((_, i) => this.getColormapColor(i / Math.max(1, this.recurrencePoints.length - 1)));
                this.chart.options.scales.x.title.text = this.ch1; this.chart.options.scales.y.title.text = this.ch2;
                this.chart.data.datasets = [{ label: `${this.ch1} vs ${this.ch2}`, data: this.recurrencePoints, backgroundColor: colors, pointRadius: 2, showLine: false }];
                this.chart.update('none');
            }

            // ‚îÄ‚îÄ Window / position ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            setWindowSize(val) {
                const s = Math.min(parseFloat(val), this.duration);
                this.windowSize = Math.min(Math.floor(this.sr * s), this.nSamples);
                document.getElementById(`windowVal-${this.id}`).textContent = s.toFixed(1);
                const sl = document.getElementById(`position-${this.id}`); sl.max = Math.max(0, this.nSamples - this.windowSize);
                if (this.position > sl.max) { this.position = parseInt(sl.max); sl.value = this.position; }
                // Changing window size invalidates accumulated polar data (chunk boundaries shift)
                this._resetPolarAccum();
                this.updateChart();
            }
            setPosition(val) {
                const newPos = parseInt(val);
                // Detect backward scrub in position slider ‚Üí reset polar accumulation
                if (newPos < this.position - this.windowSize) {
                    this._resetPolarAccum();
                }
                this.position = newPos;
                this.updateChart();
                this.updateTimeDisplay();
            }

            // ‚îÄ‚îÄ Playback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            play() {
                this.isPlaying = true;
                document.getElementById(`status-${this.id}`).textContent = 'üî¥ Playing';
                document.getElementById(`status-${this.id}`).className = 'status playing';
                this.animate();
            }
            pause() {
                this.isPlaying = false;
                document.getElementById(`status-${this.id}`).textContent = '‚èπ Paused';
                document.getElementById(`status-${this.id}`).className = 'status paused';
                if (this.animationId) cancelAnimationFrame(this.animationId);
            }
            reset() {
                this.pause(); this.position = 0; this.recurrencePoints = [];
                this._resetPolarAccum();
                document.getElementById(`position-${this.id}`).value = 0;
                this.resetZoom(); this.updateChart(); this.updateTimeDisplay();
            }
            animate() {
                if (!this.isPlaying || !this.data) return;
                const step = Math.max(1, Math.floor(this.sr * 0.02 * this.speed));
                this.position += step;
                const maxPos = this.nSamples - this.windowSize;
                if (this.position >= maxPos) {
                    // Wrap around: reset polar accum so it restarts cleanly
                    this.position = 0;
                    this._resetPolarAccum();
                }
                document.getElementById(`position-${this.id}`).value = this.position;
                this.updateChart(); this.updateTimeDisplay();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            updateTimeDisplay() {
                document.getElementById(`time-${this.id}`).textContent =
                    `${(this.position / this.sr).toFixed(2)}s / ${this.duration.toFixed(2)}s`;
            }

            // ‚îÄ‚îÄ Master dispatcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            updateChart() {
                if (!this.data) return;
                if ((this.plotType === 'time' || this.plotType === 'polar' || this.plotType === 'xor') && !this.selectedChannels.length) return;
                const start = this.position, end = Math.min(start + this.windowSize, this.nSamples);
                if (this.plotType === 'time') { this.viewMode === 'split' ? this.createSplitView(start, end) : this.updateTimeChart(start, end); }
                else if (this.plotType === 'xor') { this.updateXorChart(start, end); }
                else if (this.plotType === 'chvsch') { this.updateChVsChChart(start, end); }
                else if (this.plotType === 'polar') { this.updatePolarChart(start, end); }
                else if (this.plotType === 'polarRatio') { this.updatePolarRatioChart(start, end); }
                else if (this.plotType === 'recurrence') { this.updateRecurrenceChart(start, end); }
            }

            // ‚îÄ‚îÄ Individual renderers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

            updateTimeChart(start, end) {
                const labels = this.data.time.slice(start, end).map(t => t.toFixed(3));
                this.chart.data.labels = labels;
                this.chart.data.datasets = this.selectedChannels.map((ch, i) => ({
                    label: ch, data: this.data.signals[ch].slice(start, end),
                    borderColor: this.getChannelColor(ch, i), borderWidth: this.getChannelThickness(ch),
                    pointRadius: 0, fill: false, tension: 0.1
                }));
                this.chart.options.scales.x.title.text = 'Time (s)';
                this.chart.options.scales.y.title.text = 'Amplitude';
                this.chart.update('none');
            }

            updateChVsChChart(start, end) {
                if (!this.ch1 || !this.ch2) { this.chart.data.datasets = []; this.chart.update('none'); return; }
                const d1 = this.data.signals[this.ch1].slice(start, end), d2 = this.data.signals[this.ch2].slice(start, end);
                const pts = d1.map((x, i) => ({ x, y: d2[i] }));
                const sc = pts.map((_, i) => { const r = i / pts.length; return `rgba(${Math.floor(r * 255)},${Math.floor(212 - r * 100)},${Math.floor(255 - r * 155)},0.8)`; });
                this.chart.options.scales.x.title.text = this.ch1; this.chart.options.scales.y.title.text = this.ch2;
                this.chart.data.datasets = [{ label: `${this.ch1} vs ${this.ch2}`, data: pts, borderColor: COLORS[0], backgroundColor: sc, pointRadius: 2, pointBackgroundColor: sc, showLine: true, borderWidth: 1.5, tension: 0 }];
                this.chart.update('none');
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // POLAR CHART ‚Äî cumulative fix
            //
            // Previous bug: every animation frame appended the FULL current window
            // to polarAccum, so at 50 fps the buffer flooded in < 1 second and
            // every sample was triple/quadruple-counted.
            //
            // Fix: _appendPolarAccum() only commits the NEW portion (samples after
            // the last committed index), so each sample is stored exactly once
            // regardless of frame rate or window overlap.
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            updatePolarChart(start, end) {
                const datasets = [];
                let totalAccumPts = 0;

                this.selectedChannels.forEach((ch, idx) => {
                    let pts;

                    if (this.polarMode === 'cumulative') {
                        this._appendPolarAccum(ch, start, end);
                        pts = this.polarAccum[ch];
                        totalAccumPts = Math.max(totalAccumPts, pts.length);
                    } else {
                        // "Latest" mode: compute only the current window
                        pts = this._computePolarPoints(ch, start, end);
                    }

                    datasets.push({
                        label: ch,
                        data: pts,
                        borderColor: this.getChannelColor(ch, idx),
                        backgroundColor: this.getChannelColor(ch, idx) + '40',
                        pointRadius: 1,
                        showLine: true,
                        borderWidth: this.getChannelThickness(ch),
                        fill: false
                    });
                });

                // Reference unit circle
                const ref = Array.from({ length: 73 }, (_, i) => ({
                    x: Math.cos(i * 5 * Math.PI / 180),
                    y: Math.sin(i * 5 * Math.PI / 180)
                }));
                datasets.unshift({
                    label: 'Reference (r=1)',
                    data: ref,
                    borderColor: 'rgba(255,255,255,0.2)',
                    pointRadius: 0,
                    showLine: true,
                    borderWidth: 1,
                    borderDash: [5, 5]
                });

                this.chart.data.datasets = datasets;
                this.chart.update('none');

                // Update info bar
                const infoEl = document.getElementById(`polarAccumInfo-${this.id}`);
                if (this.polarMode === 'cumulative') {
                    const coveredS = (end / this.sr).toFixed(1);
                    infoEl.innerHTML = `<strong>Cumulative polar</strong> ‚Äî ${totalAccumPts.toLocaleString()} pts accumulated | ${coveredS}s covered | period=${this.period.toFixed(1)}s`;
                    infoEl.style.display = 'block';
                } else {
                    infoEl.innerHTML = `<strong>Latest polar</strong> ‚Äî showing current ${((end - start) / this.sr).toFixed(1)}s window | period=${this.period.toFixed(1)}s`;
                    infoEl.style.display = 'block';
                }
            }

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // POLAR RATIO CHART
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            updatePolarRatioChart(start, end) {
                if (!this.ch1 || !this.ch2) return;
                const s1 = this.data.signals[this.ch1].slice(start, end);
                const s2 = this.data.signals[this.ch2].slice(start, end);
                const pts = [];
                for (let i = 0; i < s1.length; i += 2) {
                    const absIdx = start + i;
                    const theta = ((absIdx / this.sr) / this.period) * 2 * Math.PI;
                    const r = Math.abs(s2[i]) > 0.001 ? Math.min(Math.abs(s1[i]) / Math.abs(s2[i]), 5) : 0;
                    pts.push({ x: r * Math.cos(theta), y: r * Math.sin(theta) });
                }
                const refs = [1, 2, 3].map(radius => ({
                    label: `r=${radius}`,
                    data: Array.from({ length: 37 }, (_, i) => ({
                        x: radius * Math.cos(i * 10 * Math.PI / 180),
                        y: radius * Math.sin(i * 10 * Math.PI / 180)
                    })),
                    borderColor: 'rgba(255,255,255,0.15)',
                    pointRadius: 0, showLine: true, borderWidth: 1
                }));
                this.chart.data.datasets = [
                    ...refs,
                    {
                        label: `|${this.ch1}|/|${this.ch2}|`,
                        data: pts,
                        borderColor: COLORS[0],
                        backgroundColor: COLORS[0] + '40',
                        pointRadius: 1,
                        showLine: true,
                        borderWidth: 2
                    }
                ];
                this.chart.update('none');

                const infoEl = document.getElementById(`polarAccumInfo-${this.id}`);
                infoEl.innerHTML = `<strong>Polar Ratio</strong> ‚Äî |${this.ch1}| / |${this.ch2}| | period=${this.period.toFixed(1)}s`;
                infoEl.style.display = 'block';
            }

            destroy() { this.pause(); this._destroyChart(); document.getElementById(`window-${this.id}`).remove(); }
        }

        function addWindow() {
            if (Object.keys(windows).length >= 4) { alert('Maximum 4 windows'); return; }
            windowCounter++;
            windows[windowCounter] = new SignalWindow(windowCounter);
        }
        function removeWindow(id) {
            if (Object.keys(windows).length <= 1) return;
            windows[id].destroy(); delete windows[id];
        }
        addWindow();
    </script>
</body>

</html>