<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECG/EEG Signal Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .window {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .window-title {
            font-size: 1.2rem;
            color: #00d4ff;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: black;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.8rem;
            color: #aaa;
        }

        select,
        input[type="file"] {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.9rem;
        }

        select option {
            background: #1a1a2e;
        }

        .chart-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            height: 350px;
            position: relative;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 5px;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .zoom-btn:hover {
            background: #00d4ff;
        }

        .zoom-btn.active {
            background: #00d4ff;
            box-shadow: 0 0 10px #00d4ff;
        }

        .zoom-axis-btns {
            display: flex;
            gap: 3px;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid rgba(255, 255, 255, 0.3);
        }

        .axis-btn {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .axis-btn.active {
            background: #00d4ff;
            border-color: #00d4ff;
        }

        .axis-btn:hover {
            border-color: #00d4ff;
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .playback-controls button {
            font-size: 1.2rem;
            padding: 10px 20px;
        }

        .slider-container {
            flex: 1;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }

        .time-display {
            font-size: 1rem;
            color: #00d4ff;
            min-width: 120px;
            text-align: right;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .status.playing {
            background: #28a745;
        }

        .status.paused {
            background: #6c757d;
        }

        .channel-select {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .channel-btn {
            padding: 5px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: transparent;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .channel-btn.active {
            background: #00d4ff;
            border-color: #00d4ff;
        }

        .settings {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .settings input[type="range"] {
            width: 120px;
        }

        .add-window-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info {
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 10px;
        }

        .polar-canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .polar-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üìä ECG/EEG Signal Viewer</h1>
        <p style="color: #888; margin-top: 5px;">Scroll to zoom </p>
    </div>

    <div class="container" id="windows-container"></div>

    <button class="btn btn-primary add-window-btn" onclick="addWindow()">+</button>

    <script>
        const COLORS = ['#00d4ff', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a55eea', '#ff9f43', '#26de81', '#fd79a8'];
        let windowCounter = 0;
        let windows = {};

        class SignalWindow {
            constructor(id) {
                this.id = id;
                this.data = null;
                this.channels = [];
                this.selectedChannels = [];
                this.chart = null;
                this.isPlaying = false;
                this.position = 0;
                this.speed = 1;
                this.period = 1;
                this.windowSize = 2000;
                this.plotType = 'time';
                this.animationId = null;
                this.zoomLevel = 1;

                this.createElement();
            }

            createElement() {
                const html = `
                    <div class="window" id="window-${this.id}">
                        <div class="window-header">
                            <span class="window-title">üìä Window ${this.id}</span>
                            <button class="btn btn-danger" onclick="removeWindow(${this.id})">‚úï</button>
                        </div>
                        
                        <div class="controls">
                            <div class="control-group">
                                <label>Data Source</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="file" id="file-${this.id}" accept=".csv,.edf" onchange="windows[${this.id}].loadFile(event)">
                                    <button class="btn btn-primary" onclick="windows[${this.id}].loadSample()">Demo</button>
                                </div>
                            </div>
                            <div class="control-group">
                                <label>Plot Type</label>
                                <select id="plotType-${this.id}" onchange="windows[${this.id}].setPlotType(this.value)">
                                    <option value="time">Signal vs Time</option>
                                    <option value="chvsch">Channel vs Channel</option>
                                    <option value="polar">Polar Plot</option>
                                    <option value="polarRatio">Polar Ratio (|Ch1|/|Ch2|)</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="info" id="info-${this.id}">No data loaded</div>
                        
                        <div class="channel-select" id="channels-${this.id}"></div>
                        
                        <div class="channel-dropdowns" id="chDropdowns-${this.id}" style="display:none; margin-bottom: 15px;">
                            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                <div class="control-group">
                                    <label style="color: #00d4ff;">Channel 1 (X)</label>
                                    <select id="ch1-${this.id}" onchange="windows[${this.id}].setCh1(this.value)" style="min-width: 120px;"></select>
                                </div>
                                <div class="control-group">
                                    <label style="color: #ff6b6b;">Channel 2 (Y)</label>
                                    <select id="ch2-${this.id}" onchange="windows[${this.id}].setCh2(this.value)" style="min-width: 120px;"></select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="settings">
                            <div class="control-group">
                                <label>Speed: <span id="speedVal-${this.id}">1.0</span>x</label>
                                <input type="range" id="speedSlider-${this.id}" min="0.1" max="5" step="0.1" value="1" 
                                    onchange="windows[${this.id}].setSpeed(this.value)">
                            </div>
                            <div class="control-group" id="periodGroup-${this.id}" style="display:none;">
                                <label>Period: <span id="periodVal-${this.id}">1.0</span>s</label>
                                <input type="range" min="0.2" max="5" step="0.1" value="1" 
                                    onchange="windows[${this.id}].setPeriod(this.value)">
                            </div>
                            <div class="control-group" id="windowGroup-${this.id}">
                                <label>Window: <span id="windowVal-${this.id}">4.0</span>s</label>
                                <input type="range" id="windowSlider-${this.id}" min="0.5" max="20" step="0.5" value="4" 
                                    onchange="windows[${this.id}].setWindowSize(this.value)">
                            </div>
                        </div>
                        
                        <div class="chart-container" id="chartContainer-${this.id}">
                            <div class="zoom-controls">
                                <button class="zoom-btn" onclick="windows[${this.id}].zoomIn()" title="Zoom In">+</button>
                                <button class="zoom-btn" onclick="windows[${this.id}].zoomOut()" title="Zoom Out">‚àí</button>
                                <button class="zoom-btn" onclick="windows[${this.id}].resetZoom()" title="Reset">‚Ü∫</button>
                                <div class="zoom-axis-btns">
                                    <button class="axis-btn active" id="zoomXY-${this.id}" onclick="windows[${this.id}].setZoomMode('xy', this)" title="Zoom Both Axes">XY</button>
                                    <button class="axis-btn" id="zoomX-${this.id}" onclick="windows[${this.id}].setZoomMode('x', this)" title="Zoom X Axis Only">X</button>
                                    <button class="axis-btn" id="zoomY-${this.id}" onclick="windows[${this.id}].setZoomMode('y', this)" title="Zoom Y Axis Only">Y</button>
                                </div>
                            </div>
                            <canvas id="chart-${this.id}"></canvas>
                        </div>
                        
                        <div class="playback-controls">
                            <button class="btn btn-success" onclick="windows[${this.id}].play()">‚ñ∂</button>
                            <button class="btn btn-warning" onclick="windows[${this.id}].pause()">‚è∏</button>
                            <button class="btn btn-primary" onclick="windows[${this.id}].reset()">‚Ü∫</button>
                            <div class="slider-container">
                                <input type="range" id="position-${this.id}" min="0" max="100" value="0"
                                    oninput="windows[${this.id}].setPosition(this.value)">
                            </div>
                            <div class="time-display">
                                <span class="status paused" id="status-${this.id}">‚èπ Paused</span>
                                <div id="time-${this.id}">0.00s / 0.00s</div>
                            </div>
                        </div>
                    </div>
                `;

                document.getElementById('windows-container').insertAdjacentHTML('beforeend', html);
                this.initChart();
            }

            initChart() {
                const ctx = document.getElementById(`chart-${this.id}`).getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: [], datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        plugins: {
                            legend: { labels: { color: '#fff' } },
                            zoom: {
                                zoom: {
                                    wheel: { enabled: true },
                                    pinch: { enabled: true },
                                    mode: 'xy'
                                },
                                pan: {
                                    enabled: true,
                                    mode: 'xy'
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: '#aaa' },
                                title: { display: true, text: 'Time (s)', color: '#aaa' }
                            },
                            y: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: '#aaa' },
                                title: { display: true, text: 'Amplitude', color: '#aaa' }
                            }
                        }
                    }
                });
            }

            initScatterChart() {
                this.chart.destroy();
                const ctx = document.getElementById(`chart-${this.id}`).getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                            legend: { labels: { color: '#fff' } },
                            zoom: {
                                zoom: {
                                    wheel: { enabled: true },
                                    pinch: { enabled: true },
                                    mode: 'xy'
                                },
                                pan: {
                                    enabled: true,
                                    mode: 'xy'
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: '#aaa' },
                                title: { display: true, text: '', color: '#00d4ff' }
                            },
                            y: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: '#aaa' },
                                title: { display: true, text: '', color: '#ff6b6b' }
                            }
                        }
                    }
                });
            }

            initPolarChart() {
                this.chart.destroy();
                const ctx = document.getElementById(`chart-${this.id}`).getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                            legend: { labels: { color: '#fff' } },
                            zoom: {
                                zoom: {
                                    wheel: { enabled: true },
                                    pinch: { enabled: true },
                                    mode: 'xy'
                                },
                                pan: { enabled: true, mode: 'xy' }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: '#aaa' },
                                title: { display: true, text: 'X (r¬∑cos Œ∏)', color: '#aaa' }
                            },
                            y: {
                                grid: { color: 'rgba(255,255,255,0.1)' },
                                ticks: { color: '#aaa' },
                                title: { display: true, text: 'Y (r¬∑sin Œ∏)', color: '#aaa' }
                            }
                        }
                    }
                });
            }

            zoomIn() {
                this.chart.zoom(1.2);
            }

            zoomOut() {
                this.chart.zoom(0.8);
            }

            resetZoom() {
                this.chart.resetZoom();
            }

            setZoomMode(mode, btn) {
                // Update active button
                document.querySelectorAll(`#window-${this.id} .axis-btn`).forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Update chart zoom/pan mode
                this.chart.options.plugins.zoom.zoom.mode = mode;
                this.chart.options.plugins.zoom.pan.mode = mode;
                this.chart.update('none');
            }

            zoomInX() {
                this.chart.zoom({ x: 1.2 });
            }

            zoomInY() {
                this.chart.zoom({ y: 1.2 });
            }

            zoomOutX() {
                this.chart.zoom({ x: 0.8 });
            }

            zoomOutY() {
                this.chart.zoom({ y: 0.8 });
            }

            async loadSample() {
                const res = await fetch('/api/sample');
                const info = await res.json();
                if (info.success) await this.loadData(info);
            }

            async loadFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                const formData = new FormData();
                formData.append('file', file);

                const res = await fetch('/api/upload', { method: 'POST', body: formData });
                const info = await res.json();

                if (info.success) await this.loadData(info);
                else alert('Error: ' + info.error);
            }

            async loadData(info) {
                this.channels = info.channels;
                this.sr = info.sr;
                this.duration = info.duration;
                this.nSamples = info.n_samples;

                const res = await fetch('/api/all_data');
                this.data = await res.json();

                document.getElementById(`info-${this.id}`).textContent =
                    `${this.channels.length} channels | ${this.sr.toFixed(0)} Hz | ${this.duration.toFixed(1)}s`;

                // Update channel buttons
                const container = document.getElementById(`channels-${this.id}`);
                container.innerHTML = this.channels.map((ch, i) =>
                    `<button class="channel-btn ${i < 2 ? 'active' : ''}" 
                        onclick="windows[${this.id}].toggleChannel('${ch}', this)">${ch}</button>`
                ).join('');

                this.selectedChannels = this.channels.slice(0, Math.min(2, this.channels.length));

                // Update channel dropdowns for Ch vs Ch and Polar Ratio
                const ch1Select = document.getElementById(`ch1-${this.id}`);
                const ch2Select = document.getElementById(`ch2-${this.id}`);
                const chOptions = this.channels.map(ch => `<option value="${ch}">${ch}</option>`).join('');
                ch1Select.innerHTML = chOptions;
                ch2Select.innerHTML = chOptions;
                if (this.channels.length > 1) {
                    ch2Select.selectedIndex = 1;
                }
                this.ch1 = this.channels[0];
                this.ch2 = this.channels.length > 1 ? this.channels[1] : this.channels[0];

                // Update window slider max to signal duration
                const windowSlider = document.getElementById(`windowSlider-${this.id}`);
                windowSlider.max = this.duration.toFixed(1);

                // Set initial window size (4s or signal duration, whichever is smaller)
                const initialWindow = Math.min(4, this.duration);
                windowSlider.value = initialWindow;
                document.getElementById(`windowVal-${this.id}`).textContent = initialWindow.toFixed(1);
                this.windowSize = Math.floor(this.sr * initialWindow);

                const slider = document.getElementById(`position-${this.id}`);
                slider.max = Math.max(0, this.nSamples - this.windowSize);

                this.updateChart();
            }

            toggleChannel(ch, btn) {
                if (this.selectedChannels.includes(ch)) {
                    this.selectedChannels = this.selectedChannels.filter(c => c !== ch);
                    btn.classList.remove('active');
                } else {
                    this.selectedChannels.push(ch);
                    btn.classList.add('active');
                }
                this.updateChart();
            }

            setCh1(val) {
                this.ch1 = val;
                this.updateChart();
            }

            setCh2(val) {
                this.ch2 = val;
                this.updateChart();
            }

            setPlotType(type) {
                this.plotType = type;
                document.getElementById(`periodGroup-${this.id}`).style.display =
                    type.includes('polar') ? 'block' : 'none';

                // Show/hide channel buttons vs dropdowns
                const channelBtns = document.getElementById(`channels-${this.id}`);
                const channelDropdowns = document.getElementById(`chDropdowns-${this.id}`);

                if (type === 'chvsch' || type === 'polarRatio') {
                    channelBtns.style.display = 'none';
                    channelDropdowns.style.display = 'block';
                } else {
                    channelBtns.style.display = 'flex';
                    channelDropdowns.style.display = 'none';
                }

                if (type === 'chvsch') {
                    this.initScatterChart();
                } else if (type.includes('polar')) {
                    this.initPolarChart();
                } else if (this.chart.config.type !== 'line') {
                    this.chart.destroy();
                    this.initChart();
                }

                this.updateChart();
            }

            setSpeed(val) {
                this.speed = parseFloat(val);
                document.getElementById(`speedVal-${this.id}`).textContent = val;
            }

            setPeriod(val) {
                this.period = parseFloat(val);
                document.getElementById(`periodVal-${this.id}`).textContent = val;
                this.updateChart();
            }

            setWindowSize(val) {
                const seconds = parseFloat(val);
                // Clamp to signal duration
                const clampedSeconds = Math.min(seconds, this.duration);
                this.windowSize = Math.floor(this.sr * clampedSeconds);

                // Make sure window doesn't exceed signal
                if (this.windowSize > this.nSamples) {
                    this.windowSize = this.nSamples;
                }

                document.getElementById(`windowVal-${this.id}`).textContent = clampedSeconds.toFixed(1);

                const slider = document.getElementById(`position-${this.id}`);
                slider.max = Math.max(0, this.nSamples - this.windowSize);

                // Reset position if it's now out of bounds
                if (this.position > slider.max) {
                    this.position = parseInt(slider.max);
                    slider.value = this.position;
                }

                this.updateChart();
            }

            setPosition(val) {
                this.position = parseInt(val);
                this.updateChart();
                this.updateTimeDisplay();
            }

            play() {
                this.isPlaying = true;
                document.getElementById(`status-${this.id}`).textContent = 'üî¥ Playing';
                document.getElementById(`status-${this.id}`).className = 'status playing';
                this.animate();
            }

            pause() {
                this.isPlaying = false;
                document.getElementById(`status-${this.id}`).textContent = '‚èπ Paused';
                document.getElementById(`status-${this.id}`).className = 'status paused';
                if (this.animationId) cancelAnimationFrame(this.animationId);
            }

            reset() {
                this.pause();
                this.position = 0;
                document.getElementById(`position-${this.id}`).value = 0;
                this.resetZoom();
                this.updateChart();
                this.updateTimeDisplay();
            }

            animate() {
                if (!this.isPlaying || !this.data) return;

                // Ensure step is at least 1 to prevent stopping at low speeds
                const step = Math.max(1, Math.floor(this.sr * 0.02 * this.speed));
                this.position += step;

                const maxPos = this.nSamples - this.windowSize;
                if (this.position >= maxPos) this.position = 0;

                document.getElementById(`position-${this.id}`).value = this.position;
                this.updateChart();
                this.updateTimeDisplay();

                this.animationId = requestAnimationFrame(() => this.animate());
            }

            updateTimeDisplay() {
                const currentTime = this.position / this.sr;
                document.getElementById(`time-${this.id}`).textContent =
                    `${currentTime.toFixed(2)}s / ${this.duration.toFixed(2)}s`;
            }

            updateChart() {
                if (!this.data) return;

                // For time and polar plots, need selectedChannels
                if ((this.plotType === 'time' || this.plotType === 'polar') && !this.selectedChannels.length) return;

                const start = this.position;
                const end = Math.min(start + this.windowSize, this.nSamples);

                if (this.plotType === 'time') this.updateTimeChart(start, end);
                else if (this.plotType === 'chvsch') this.updateChVsChChart(start, end);
                else if (this.plotType === 'polar') this.updatePolarChart(start, end);
                else if (this.plotType === 'polarRatio') this.updatePolarRatioChart(start, end);
            }

            updateTimeChart(start, end) {
                const time = this.data.time.slice(start, end);
                const labels = time.map(t => t.toFixed(3));

                const datasets = this.selectedChannels.map((ch, i) => ({
                    label: ch,
                    data: this.data.signals[ch].slice(start, end),
                    borderColor: COLORS[i % COLORS.length],
                    borderWidth: 1.5,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.1
                }));

                this.chart.options.scales.x.title.text = 'Time (s)';
                this.chart.options.scales.y.title.text = 'Amplitude';
                this.chart.data.labels = labels;
                this.chart.data.datasets = datasets;
                this.chart.update('none');
            }

            updateChVsChChart(start, end) {
                if (!this.ch1 || !this.ch2) {
                    this.chart.data.datasets = [];
                    this.chart.update('none');
                    return;
                }

                const ch1 = this.ch1;
                const ch2 = this.ch2;

                const data1 = this.data.signals[ch1].slice(start, end);
                const data2 = this.data.signals[ch2].slice(start, end);

                // Create gradient colors based on time progression
                const points = data1.map((x, i) => ({ x: x, y: data2[i] }));

                // Create segments for color gradient
                const segmentColors = points.map((_, i) => {
                    const ratio = i / points.length;
                    const r = Math.floor(0 + ratio * 255);
                    const g = Math.floor(212 - ratio * 100);
                    const b = Math.floor(255 - ratio * 155);
                    return `rgba(${r}, ${g}, ${b}, 0.8)`;
                });

                this.chart.options.scales.x.title.text = ch1;
                this.chart.options.scales.y.title.text = ch2;

                this.chart.data.datasets = [{
                    label: `${ch1} vs ${ch2}`,
                    data: points,
                    borderColor: COLORS[0],
                    backgroundColor: segmentColors,
                    pointRadius: 2,
                    pointBackgroundColor: segmentColors,
                    showLine: true,
                    borderWidth: 1.5,
                    tension: 0
                }];

                this.chart.update('none');
            }

            updatePolarChart(start, end) {
                const datasets = [];
                const samplesPerRevolution = Math.floor(this.sr * this.period);
                const sliceData = (start, end);

                this.selectedChannels.forEach((ch, idx) => {
                    const signal = this.data.signals[ch].slice(start, end);
                    const points = [];

                    // Convert to polar coordinates: r = signal value, theta = time
                    const minVal = Math.min(...signal);
                    const maxVal = Math.max(...signal);
                    const range = maxVal - minVal || 1;

                    for (let i = 0; i < signal.length; i += 2) { // Skip every other for performance
                        const t = i / this.sr;
                        const theta = (t / this.period) * 2 * Math.PI;
                        const r = (signal[i] - minVal) / range + 0.5; // Normalize to 0.5-1.5

                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        points.push({ x, y });
                    }

                    datasets.push({
                        label: ch,
                        data: points,
                        borderColor: COLORS[idx % COLORS.length],
                        backgroundColor: COLORS[idx % COLORS.length] + '40',
                        pointRadius: 1,
                        showLine: true,
                        borderWidth: 2,
                        fill: false
                    });
                });

                // Add reference circles
                const refCircle = [];
                for (let i = 0; i <= 360; i += 5) {
                    const theta = (i / 180) * Math.PI;
                    refCircle.push({ x: Math.cos(theta), y: Math.sin(theta) });
                }

                datasets.unshift({
                    label: 'Reference',
                    data: refCircle,
                    borderColor: 'rgba(255,255,255,0.2)',
                    pointRadius: 0,
                    showLine: true,
                    borderWidth: 1,
                    borderDash: [5, 5]
                });

                this.chart.data.datasets = datasets;
                this.chart.update('none');
            }

            updatePolarRatioChart(start, end) {
                if (!this.ch1 || !this.ch2) return;

                const ch1 = this.ch1;
                const ch2 = this.ch2;

                const sig1 = this.data.signals[ch1].slice(start, end);
                const sig2 = this.data.signals[ch2].slice(start, end);

                const points = [];

                for (let i = 0; i < sig1.length; i += 2) {
                    const t = i / this.sr;
                    const theta = (t / this.period) * 2 * Math.PI;
                    const r = Math.abs(sig2[i]) > 0.001 ? Math.abs(sig1[i]) / Math.abs(sig2[i]) : 0;
                    const rClamped = Math.min(r, 5); // Clamp extreme values

                    const x = rClamped * Math.cos(theta);
                    const y = rClamped * Math.sin(theta);
                    points.push({ x, y });
                }

                // Reference circles
                const refCircles = [];
                for (let radius = 1; radius <= 3; radius++) {
                    const circle = [];
                    for (let i = 0; i <= 360; i += 10) {
                        const theta = (i / 180) * Math.PI;
                        circle.push({ x: radius * Math.cos(theta), y: radius * Math.sin(theta) });
                    }
                    refCircles.push({
                        label: `r=${radius}`,
                        data: circle,
                        borderColor: 'rgba(255,255,255,0.15)',
                        pointRadius: 0,
                        showLine: true,
                        borderWidth: 1
                    });
                }

                this.chart.data.datasets = [
                    ...refCircles,
                    {
                        label: `|${ch1}| / |${ch2}|`,
                        data: points,
                        borderColor: COLORS[0],
                        backgroundColor: COLORS[0] + '40',
                        pointRadius: 1,
                        showLine: true,
                        borderWidth: 2
                    }
                ];

                this.chart.update('none');
            }

            destroy() {
                this.pause();
                if (this.chart) this.chart.destroy();
                document.getElementById(`window-${this.id}`).remove();
            }
        }

        function addWindow() {
            if (Object.keys(windows).length >= 4) {
                alert('Maximum 4 windows');
                return;
            }
            windowCounter++;
            windows[windowCounter] = new SignalWindow(windowCounter);
        }

        function removeWindow(id) {
            if (Object.keys(windows).length <= 1) return;
            windows[id].destroy();
            delete windows[id];
        }

        addWindow();
    </script>
</body>


</html>
